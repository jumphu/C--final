# 为什么位置误差比速度误差大？

## 现象观察

从测试结果中我们看到：
- **速度误差**: 0.00% ? 完美
- **位置误差**: 2.94% ? 较大

为什么会有这种差异？

---

## 数学原理

### 1. 数值积分的误差传播

在显式欧拉法中，我们有两个更新步骤：

#### 第一步：速度更新
```
v(t+Δt) = v(t) + a・Δt
```

#### 第二步：位置更新
```
x(t+Δt) = x(t) + v(t)・Δt
```

关键区别：**位置的更新依赖于速度，但速度的更新不依赖于位置**。

---

## 详细分析

### 速度更新：一阶精度，无累积误差

对于**恒定加速度** a = -μg：

**理论速度**：
```
v_exact(t) = v? + a・t
```

**欧拉法速度**（经过 n 步，Δt・n = t）：
```
v_euler(t) = v? + a・Δt・n = v? + a・t
```

**结论**：对于恒定加速度，欧拉法的速度计算是**精确的**！

这就是为什么速度误差为 0%。

---

### 位置更新：误差累积

#### 理论位置（解析解）
```
x_exact(t) = v?・t + ?a・t?
```

#### 欧拉法位置
使用前向差分：
```
x(t+Δt) = x(t) + v(t)・Δt
```

展开第 k 步：
```
x_k = x_{k-1} + v_{k-1}・Δt
    = x_{k-1} + (v? + a・(k-1)・Δt)・Δt
```

累加 n 步：
```
x_n = x? + Σ[k=1 to n] (v? + a・(k-1)・Δt)・Δt
    = x? + v?・n・Δt + a・Δt?・Σ[k=1 to n](k-1)
    = x? + v?・t + a・Δt?・(n-1)・n/2
    = x? + v?・t + a・t・(t-Δt)/2
    = x? + v?・t + ?a・t? - ?a・t・Δt
```

**误差项**：
```
Error = x_exact - x_euler
      = (x? + v?・t + ?a・t?) - (x? + v?・t + ?a・t? - ?a・t・Δt)
      = ?a・t・Δt
```

---

## 误差量化

### 对于我们的测试案例

**参数**：
- v? = 10 m/s
- a = -2.94 m/s?
- Δt = 0.1 s
- 停止时间 t ≈ 3.4 s

**理论停止距离**：
```
x_exact = v??/(2μg) = 100/(2×0.3×9.8) = 17.0068 m
```

**误差估算**：
```
Error = ? × a × t × Δt
      = ? × (-2.94) × 3.4 × 0.1
      = -0.4998 m
```

**相对误差**：
```
Relative Error = |Error| / x_exact × 100%
               = 0.4998 / 17.0068 × 100%
               = 2.94%
```

? 与实际观测完全一致！

---

## 图示说明

### 速度-时间曲线

```
速度
  ^
  |  理论 (直线)
  |  ●●●●●●●●●
  |  ●        ●
  |  ●         ●
  |  ●          ●
  |  ●           ●●●
  |  ●             ●●●
  |  ●________________●●●● 欧拉法 (完全重合)
  +-----------------------> 时间
```

对于恒定加速度，欧拉法的速度是**精确的**。

### 位置-时间曲线

```
位置
  ^
  |          理论 (抛物线)
  |         u
  |       u
  |     ●    ← 欧拉法总是落后
  |   ●
  | ●
  |●________________
  +-----------------------> 时间
  
  误差随时间累积
```

欧拉法使用**当前速度**计算下一位置，而实际应该用**平均速度**。

---

## 为什么会有误差？

### 问题根源

**欧拉法使用的**：
```
x(t+Δt) = x(t) + v(t)・Δt
          ↑
          使用起点速度
```

**应该使用的（精确）**：
```
x(t+Δt) = x(t) + v_avg・Δt
          ↑
          使用平均速度
```

其中，平均速度为：
```
v_avg = [v(t) + v(t+Δt)] / 2
      = v(t) + ?a・Δt
```

### 可视化理解

```
速度
  ^
  |     v(t+Δt) ●
  |            /|
  |     v_avg /?| ← 应该用这个面积
  |          /??|
  |   v(t) ●???| ← 欧拉法只用这个面积
  |       |????|
  |       +----+
  |       t  t+Δt
  +-----------> 时间

阴影面积 = 位移
欧拉法少算了三角形部分 ?a・Δt?
```

---

## 误差的本质

### 局部截断误差

每一步的误差（泰勒展开）：
```
x_exact(t+Δt) = x(t) + v(t)・Δt + ?a・Δt? + O(Δt?)
x_euler(t+Δt) = x(t) + v(t)・Δt

局部误差 = ?a・Δt? + O(Δt?)
         ≈ ?a・Δt?  (对于小 Δt)
```

### 全局误差累积

经过 n 步（t = n・Δt）：
```
全局误差 = Σ[k=1 to n] (?a・Δt?)
         ≈ n × (?a・Δt?)
         = (t/Δt) × (?a・Δt?)
         = ?a・t・Δt
```

**关键点**：
- 每步误差：O(Δt?)
- 累积误差：O(Δt) - 因为步数是 O(1/Δt)

---

## 对比表

| 项目 | 速度 | 位置 |
|------|------|------|
| **更新公式** | v += a・Δt | x += v・Δt |
| **对恒定加速度** | 精确 | 近似 |
| **局部误差** | 0 | O(Δt?) |
| **全局误差** | 0 | O(Δt) |
| **误差来源** | 无 | 使用当前速度而非平均速度 |
| **实际误差** | 0.00% | 2.94% |

---

## 改进方法

### 方法 1：减小时间步长

```
Δt = 0.1 s  → 误差 = 2.94%
Δt = 0.05 s → 误差 = 1.47%  (减半)
Δt = 0.01 s → 误差 = 0.29%  (1/10)
```

误差与 Δt 成正比。

### 方法 2：使用中点法

```cpp
// 计算中点速度
double v_mid = velocity[0] + 0.5 * acceleration * deltaTime;

// 使用中点速度更新位置
mass_centre[0] += v_mid * deltaTime;

// 更新速度
velocity[0] += acceleration * deltaTime;
```

**精度**：O(Δt?) → 误差变为 ~0.09%

### 方法 3：使用 Velocity Verlet

```cpp
// 1. 更新位置（使用当前速度和加速度）
mass_centre[0] += velocity[0] * deltaTime + 0.5 * acceleration * deltaTime * deltaTime;

// 2. 计算新加速度
double new_acceleration = calculateAcceleration();

// 3. 更新速度（使用平均加速度）
velocity[0] += 0.5 * (acceleration + new_acceleration) * deltaTime;
```

**精度**：O(Δt?)，对保守力更稳定

### 方法 4：使用 RK4

```cpp
// k1 = f(t, y)
double k1_v = acceleration;
double k1_x = velocity[0];

// k2 = f(t+Δt/2, y+k1・Δt/2)
double k2_v = acceleration;  // 恒定加速度
double k2_x = velocity[0] + 0.5 * k1_v * deltaTime;

// k3 = f(t+Δt/2, y+k2・Δt/2)
double k3_v = acceleration;
double k3_x = velocity[0] + 0.5 * k2_v * deltaTime;

// k4 = f(t+Δt, y+k3・Δt)
double k4_v = acceleration;
double k4_x = velocity[0] + k3_v * deltaTime;

// 更新
velocity[0] += (k1_v + 2*k2_v + 2*k3_v + k4_v) * deltaTime / 6;
mass_centre[0] += (k1_x + 2*k2_x + 2*k3_x + k4_x) * deltaTime / 6;
```

**精度**：O(Δt?) → 误差 < 0.001%

---

## 实际建议

### 当前实现（欧拉法）适用于：
- ? 实时游戏（速度要求高）
- ? 视觉效果为主
- ? 短时间模拟
- ? 可以接受 2-3% 误差

### 需要更高精度时：
- 科学模拟
- 长时间积分
- 精确碰撞检测
- 能量守恒重要

推荐使用 **Velocity Verlet** 或 **RK4**。

---

## 数学证明总结

### 为什么速度精确？

对于 v' = a（恒定）：
```
v(t+Δt) = v(t) + ∫[t to t+Δt] a dt
        = v(t) + a・Δt
```
这正是欧拉法的公式！

### 为什么位置有误差？

对于 x' = v(t)：
```
x(t+Δt) = x(t) + ∫[t to t+Δt] v(τ) dτ
        = x(t) + ∫[t to t+Δt] (v(t) + a・(τ-t)) dτ
        = x(t) + v(t)・Δt + ?a・Δt?
                          ↑
                          欧拉法缺失这一项
```

---

## 结论

**速度精确**是因为：
1. 加速度恒定
2. 速度更新公式在此情况下是精确的
3. 不依赖于其他变量

**位置有误差**是因为：
1. 位置依赖于速度
2. 使用**当前速度**而非**平均速度**
3. 误差逐步累积，与时间成正比

这是数值积分的基本特性，不是实现错误，而是方法的固有限制。

---

**关键洞察**：
> 在数值积分中，高阶导数（速度）的精度**总是**优于低阶导数（位置）的精度。

这就是为什么在物理模拟中，我们经常看到：
- 速度误差：~0.1%
- 位置误差：~1%
- 能量误差：~10%

误差会沿着导数链传播和放大！
