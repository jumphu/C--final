# 摩擦力滑行测试文档

## 测试文件
`test_friction_sliding.cpp`

## 测试目的
验证物理引擎中摩擦力模拟的准确性，测试一个AABB（轴对齐包围盒）在粗糙地面上以一定初速度滑行至静止的过程，并与理论计算结果进行对比。

## 物理原理

### 1. 摩擦力公式
```
f = μ * m * g
```
- `f`: 摩擦力（N）
- `μ`: 摩擦系数（无量纲）
- `m`: 物体质量（kg）
- `g`: 重力加速度（m/s?）

### 2. 运动学方程
在恒定摩擦力作用下：
- **减速度**: `a = -μ * g`
- **速度**: `v(t) = v? - μ * g * t`
- **停止时间**: `t_stop = v? / (μ * g)`
- **位移**: `s(t) = v? * t - 0.5 * μ * g * t?`
- **最大滑行距离**: `s_max = v?? / (2 * μ * g)`

### 3. 能量守恒
```
初始动能 = 摩擦力做功
0.5 * m * v?? = μ * m * g * s
```

## 测试内容

### 测试1：基础摩擦滑行测试
- **目的**: 验证基本的摩擦滑行模拟
- **参数**:
  - 质量: 10 kg
  - 尺寸: 2m × 2m
  - 初速度: 20 m/s
  - 摩擦系数: 0.3
  - 重力加速度: 9.8 m/s?
- **验证**: 模拟结果与理论计算的停止时间和滑行距离对比

### 测试2：不同摩擦系数对比测试
- **目的**: 验证不同摩擦系数下的滑行行为
- **测试摩擦系数**: 0.1, 0.3, 0.5, 0.7
- **固定参数**: 初速度 = 15 m/s
- **预期**: 摩擦系数越大，滑行距离越短

### 测试3：不同初速度对比测试
- **目的**: 验证不同初速度下的滑行行为
- **测试初速度**: 5, 10, 20, 30 m/s
- **固定参数**: 摩擦系数 = 0.4
- **预期**: 滑行距离与初速度的平方成正比

### 测试4：能量守恒验证
- **目的**: 验证能量守恒定律
- **验证公式**: `初始动能 = 摩擦力做功`
- **预期**: 能量误差 < 5%

## 编译和运行

### 编译
```bash
g++ -o test_friction_sliding test_friction_sliding.cpp ../src/physicalWorld.cpp ../src/shapes.cpp -I../include -std=c++11
```

### 运行
```bash
./test_friction_sliding
```

## 预期输出

### 基本输出格式
```
========================================
  测试1: 基础摩擦滑行
========================================

物理参数：
  质量: 10 kg
  尺寸: 2 x 2 m
  初速度: 20 m/s
  摩擦系数: 0.3
  重力加速度: 9.8 m/s?
  时间步长: 0.01 s

理论计算结果：
  减速度: 2.940 m/s?
  停止时间: 6.803 s
  滑行距离: 68.027 m
  最终速度: 0.000 m/s

模拟结果：
  停止时间: 6.810 s
  滑行距离: 68.100 m
  最终速度: 0.009 m/s
  模拟步数: 681

对比分析：
  时间误差: 0.007 s (0.10%)
  距离误差: 0.073 m (0.11%)
  ? 测试通过：模拟结果与理论计算接近
```

## 验收标准

### 成功标准
1. **精度要求**: 模拟结果与理论计算的误差 < 5%
2. **能量守恒**: 能量误差 < 5%
3. **趋势正确**:
   - 摩擦系数越大 → 滑行距离越短
   - 初速度越大 → 滑行距离越长（二次关系）
   - 最终速度 ≈ 0

### 失败情况
- 误差 > 5%
- 能量不守恒
- 物体未能停止或提前停止

## 物理引擎实现要点

### 1. 摩擦力施加
在 `PhysicalWorld::update()` 中：
```cpp
// 应用摩擦力（在地面上时）
double friction = ground.getFriction();
vx *= (1.0 - friction * deltaTime);
```

### 2. 地面碰撞检测
```cpp
if (shape->HasCollidedWithGround(ground.getYLevel())) {
    placeShapeOnGround(*shape, ground);
    // 应用摩擦力和弹性系数
}
```

### 3. 摩擦系数传递
```cpp
shape.fraction = ground.getFriction();
```

## 注意事项

1. **时间步长**: 使用小时间步长（如0.01s）以提高精度
2. **速度阈值**: 设置速度阈值（如0.01 m/s）判定物体停止
3. **弹性系数**: 设置为0以避免反弹影响测试
4. **边界范围**: 确保边界足够大，物体不会超出边界

## 理论计算示例

### 示例1: v?=20m/s, μ=0.3, g=9.8m/s?
```
减速度: a = 0.3 × 9.8 = 2.94 m/s?
停止时间: t = 20 / 2.94 = 6.803 s
滑行距离: s = 20? / (2 × 2.94) = 68.027 m
```

### 示例2: v?=10m/s, μ=0.5, g=9.8m/s?
```
减速度: a = 0.5 × 9.8 = 4.90 m/s?
停止时间: t = 10 / 4.90 = 2.041 s
滑行距离: s = 10? / (2 × 4.90) = 10.204 m
```

## 调试建议

### 如果误差过大
1. **检查摩擦力实现**: 确认摩擦力方向和大小正确
2. **检查时间步长**: 可能需要更小的时间步长
3. **检查数值积分**: 确认位置和速度更新正确
4. **检查边界条件**: 确认物体在地面上

### 如果物体未停止
1. 检查摩擦力是否正确施加
2. 检查速度更新逻辑
3. 检查是否有其他力干扰（如重力在水平方向）

### 如果物体反弹
1. 设置 `restitution = 0.0`
2. 检查地面碰撞处理逻辑

## 扩展测试

可以进一步测试：
1. 斜面上的滑行（带重力分量）
2. 多物体摩擦交互
3. 滚动摩擦与滑动摩擦
4. 变摩擦系数的表面
5. 空气阻力影响

## 参考资料
- 经典力学教材关于摩擦力的章节
- 数值积分方法（欧拉法、Verlet积分等）
- 游戏物理引擎设计模式
