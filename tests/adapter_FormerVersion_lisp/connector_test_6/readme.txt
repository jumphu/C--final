第六版，把SFML改为了EasyX

项目根目录/
├── PhysicalWorld.h          (第一部分物理逻辑)
├── Buttons.h               (第二部分按钮控制)
├── MusicPlayer.h           (第二部分音乐播放)
├── PhysicsRenderBridge.h   (接口头文件 - 需要修改)
├── PhysicsRenderBridge.cpp (接口实现 - 需要修改)
└── main.cpp               (主程序 - 需要重写)




目前控制的变量（输入端）：
1. 物理世界参数控制
// 这些值可以从UI输入，通过你的接口桥梁传递给物理世界
- gravity           // 重力加速度（9.8 m/s²）
- inclineAngle      // 倾斜角度（-90° 到 90°）
- StaticFriction    // 静摩擦系数
- timeStep          // 时间步长（控制模拟速度）
- bounds[4]         // 物理世界边界 [左, 右, 下, 上]

2. 物体属性控制
// 通过UserInput事件创建/修改物体
// CREATE_SHAPE事件可以传入：
- shape_type       // 形状类型："circle", "rectangle", 等
- position         // 初始位置（通过鼠标点击）
- mass             // 质量（通过参数输入）
- size1, size2     // 尺寸参数（半径、宽高）

3. 交互控制
// 用户直接操作
- MOUSE_DRAG       // 鼠标拖动物体
- DELETE_SHAPE     // 删除物体
- BUTTON_CLICK     // 控制按钮：开始/暂停/停止/重置
- MUSIC_TOGGLE     // 音乐开关

4. 场景状态控制
// 控制整个模拟流程
- isPaused         // 暂停/继续模拟
- start()          // 开始模拟
- stop()           // 停止模拟
- reset()          // 重置场景



可以输出的变量（输出端）：
1. 物体渲染数据
// 每个物体的RenderState包含：
- position         // 屏幕位置（已坐标转换）
- size             // 屏幕尺寸（已缩放）
- color            // 颜色（根据类型）
- type             // 形状类型
- name             // 唯一标识符

2. 物理参数显示
// 供UI显示当前参数值
- getGravity()     // 当前重力值
- getInclineAngle()// 当前倾斜角度
- getFriction()    // 当前摩擦系数
- getTimeStep()    // 当前时间步长
- isPaused()       // 当前暂停状态

3. 交互反馈
// 供UI更新按钮状态
- getButtonStates() // 按钮的点击/悬停状态
- getMusicState()   // 音乐播放器状态



支持的物理模型计算：
1. 基础运动模型
// 牛顿运动定律
- 匀速直线运动
- 匀加速运动（重力、摩擦力）
- 抛体运动

2. 碰撞模型
// 基于物理世界的碰撞检测
- 物体间碰撞（弹性和非弹性）
- 边界碰撞（墙壁）
- 与地面碰撞

3. 斜面运动
// 倾斜平面上的物体运动
- 重力分解（平行和垂直分量）
- 斜面摩擦
- 物体在斜面上的加速/减速

4. 摩擦模型
// 静摩擦和滑动摩擦
- 最大静摩擦力 = μN
- 滑动摩擦力 = μN
- 摩擦方向与运动方向相反

5. 堆叠与支撑
// 多个物体的相互作用
- 支撑关系检测
- 正压力计算
- 堆叠物体的运动

6. 复合运动
// 多种力共同作用
- 重力 + 斜面 + 摩擦
- 碰撞后的动量变化
- 多阶段运动分析




用户界面（第二部分）
    ↓
[ 用户输入：按钮点击、参数调整、鼠标拖拽 ]
    ↓
PhysicsRenderBridge（你的代码）
    ↓
[ 转换为物理事件：重力设置、物体创建、位置更新 ]
    ↓
PhysicalWorld（第一部分）
    ↓
[ 物理计算：运动方程、碰撞检测、摩擦计算 ]
    ↓
PhysicsRenderBridge（你的代码）
    ↓
[ 转换物理状态为渲染数据：位置、尺寸、颜色 ]
    ↓
渲染器（第二部分）
    ↓
[ 显示在屏幕上 ]





tips：
1，迄今为止，该代码没加场景化构建的可视化部分，但有背后运行